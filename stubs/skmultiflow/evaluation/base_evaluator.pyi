from .evaluation_data_buffer import EvaluationDataBuffer as EvaluationDataBuffer
from abc import ABCMeta, abstractmethod
from skmultiflow.core import BaseSKMObject as BaseSKMObject
from skmultiflow.data.base_stream import Stream as Stream
from skmultiflow.metrics import ClassificationPerformanceEvaluator as ClassificationPerformanceEvaluator, MultiLabelClassificationPerformanceEvaluator as MultiLabelClassificationPerformanceEvaluator, MultiTargetRegressionMeasurements as MultiTargetRegressionMeasurements, RegressionMeasurements as RegressionMeasurements, RunningTimeMeasurements as RunningTimeMeasurements, WindowClassificationPerformanceEvaluator as WindowClassificationPerformanceEvaluator, WindowMultiLabelClassificationPerformanceEvaluator as WindowMultiLabelClassificationPerformanceEvaluator, WindowMultiTargetRegressionMeasurements as WindowMultiTargetRegressionMeasurements, WindowRegressionMeasurements as WindowRegressionMeasurements
from skmultiflow.utils import calculate_object_size as calculate_object_size
from skmultiflow.visualization.evaluation_visualizer import EvaluationVisualizer as EvaluationVisualizer
from typing import Any, Optional

class StreamEvaluator(BaseSKMObject, metaclass=ABCMeta):
    n_wait: int = ...
    max_samples: int = ...
    batch_size: int = ...
    pretrain_size: int = ...
    max_time: int = ...
    metrics: Any = ...
    output_file: Any = ...
    show_plot: bool = ...
    restart_stream: bool = ...
    test_size: int = ...
    dynamic_test_set: bool = ...
    data_points_for_classification: bool = ...
    mean_eval_measurements: Any = ...
    current_eval_measurements: Any = ...
    model_names: Any = ...
    model: Any = ...
    n_models: int = ...
    stream: Any = ...
    visualizer: Any = ...
    n_sliding: int = ...
    global_sample_count: int = ...
    def __init__(self) -> None: ...
    @abstractmethod
    def evaluate(self, stream: Any, model: Any, model_names: Optional[Any] = ...) -> Any: ...
    @abstractmethod
    def partial_fit(self, X: Any, y: Any, classes: Optional[Any] = ..., sample_weight: Optional[Any] = ...) -> Any: ...
    @abstractmethod
    def predict(self, X: Any) -> Any: ...
    @staticmethod
    def update_progress_bar(curr: Any, total: Any, steps: Any, time: Any) -> None: ...
    def evaluation_summary(self) -> None: ...
    def get_measurements(self, model_idx: Optional[Any] = ...): ...
    def get_mean_measurements(self, model_idx: Optional[Any] = ...): ...
    def get_current_measurements(self, model_idx: Optional[Any] = ...): ...
