from ..base import MultiOutputMixin as MultiOutputMixin, RegressorMixin as RegressorMixin
from ..model_selection import check_cv as check_cv
from ..utils import check_array as check_array
from ..utils.extmath import safe_sparse_dot as safe_sparse_dot
from ..utils.validation import check_is_fitted as check_is_fitted, check_random_state as check_random_state, column_or_1d as column_or_1d
from ._base import LinearModel as LinearModel
from abc import ABCMeta, abstractmethod
from typing import Any, Optional

def lasso_path(X: Any, y: Any, *, eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., precompute: str = ..., Xy: Optional[Any] = ..., copy_X: bool = ..., coef_init: Optional[Any] = ..., verbose: bool = ..., return_n_iter: bool = ..., positive: bool = ..., **params: Any): ...
def enet_path(X: Any, y: Any, *, l1_ratio: float = ..., eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., precompute: str = ..., Xy: Optional[Any] = ..., copy_X: bool = ..., coef_init: Optional[Any] = ..., verbose: bool = ..., return_n_iter: bool = ..., positive: bool = ..., check_input: bool = ..., **params: Any): ...

class ElasticNet(MultiOutputMixin, RegressorMixin, LinearModel):
    path: Any = ...
    alpha: Any = ...
    l1_ratio: Any = ...
    fit_intercept: Any = ...
    normalize: Any = ...
    precompute: Any = ...
    max_iter: Any = ...
    copy_X: Any = ...
    tol: Any = ...
    warm_start: Any = ...
    positive: Any = ...
    random_state: Any = ...
    selection: Any = ...
    def __init__(self, alpha: float = ..., *, l1_ratio: float = ..., fit_intercept: bool = ..., normalize: bool = ..., precompute: bool = ..., max_iter: int = ..., copy_X: bool = ..., tol: float = ..., warm_start: bool = ..., positive: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...
    n_iter_: Any = ...
    coef_: Any = ...
    dual_gap_: Any = ...
    def fit(self, X: Any, y: Any, sample_weight: Optional[Any] = ..., check_input: bool = ...): ...
    @property
    def sparse_coef_(self): ...

class Lasso(ElasticNet):
    path: Any = ...
    def __init__(self, alpha: float = ..., *, fit_intercept: bool = ..., normalize: bool = ..., precompute: bool = ..., copy_X: bool = ..., max_iter: int = ..., tol: float = ..., warm_start: bool = ..., positive: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...

class LinearModelCV(MultiOutputMixin, LinearModel, metaclass=ABCMeta):
    eps: Any = ...
    n_alphas: Any = ...
    alphas: Any = ...
    fit_intercept: Any = ...
    normalize: Any = ...
    precompute: Any = ...
    max_iter: Any = ...
    tol: Any = ...
    copy_X: Any = ...
    cv: Any = ...
    verbose: Any = ...
    n_jobs: Any = ...
    positive: Any = ...
    random_state: Any = ...
    selection: Any = ...
    @abstractmethod
    def __init__(self, eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., fit_intercept: bool = ..., normalize: bool = ..., precompute: str = ..., max_iter: int = ..., tol: float = ..., copy_X: bool = ..., cv: Optional[Any] = ..., verbose: bool = ..., n_jobs: Optional[Any] = ..., positive: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> Any: ...
    mse_path_: Any = ...
    l1_ratio_: Any = ...
    alpha_: Any = ...
    alphas_: Any = ...
    coef_: Any = ...
    intercept_: Any = ...
    dual_gap_: Any = ...
    n_iter_: Any = ...
    def fit(self, X: Any, y: Any): ...

class LassoCV(RegressorMixin, LinearModelCV):
    path: Any = ...
    def __init__(self, *, eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., fit_intercept: bool = ..., normalize: bool = ..., precompute: str = ..., max_iter: int = ..., tol: float = ..., copy_X: bool = ..., cv: Optional[Any] = ..., verbose: bool = ..., n_jobs: Optional[Any] = ..., positive: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...

class ElasticNetCV(RegressorMixin, LinearModelCV):
    path: Any = ...
    l1_ratio: Any = ...
    eps: Any = ...
    n_alphas: Any = ...
    alphas: Any = ...
    fit_intercept: Any = ...
    normalize: Any = ...
    precompute: Any = ...
    max_iter: Any = ...
    tol: Any = ...
    cv: Any = ...
    copy_X: Any = ...
    verbose: Any = ...
    n_jobs: Any = ...
    positive: Any = ...
    random_state: Any = ...
    selection: Any = ...
    def __init__(self, *, l1_ratio: float = ..., eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., fit_intercept: bool = ..., normalize: bool = ..., precompute: str = ..., max_iter: int = ..., tol: float = ..., cv: Optional[Any] = ..., copy_X: bool = ..., verbose: int = ..., n_jobs: Optional[Any] = ..., positive: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...

class MultiTaskElasticNet(Lasso):
    l1_ratio: Any = ...
    alpha: Any = ...
    fit_intercept: Any = ...
    normalize: Any = ...
    max_iter: Any = ...
    copy_X: Any = ...
    tol: Any = ...
    warm_start: Any = ...
    random_state: Any = ...
    selection: Any = ...
    def __init__(self, alpha: float = ..., *, l1_ratio: float = ..., fit_intercept: bool = ..., normalize: bool = ..., copy_X: bool = ..., max_iter: int = ..., tol: float = ..., warm_start: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...
    coef_: Any = ...
    def fit(self, X: Any, y: Any): ...

class MultiTaskLasso(MultiTaskElasticNet):
    alpha: Any = ...
    fit_intercept: Any = ...
    normalize: Any = ...
    max_iter: Any = ...
    copy_X: Any = ...
    tol: Any = ...
    warm_start: Any = ...
    l1_ratio: float = ...
    random_state: Any = ...
    selection: Any = ...
    def __init__(self, alpha: float = ..., *, fit_intercept: bool = ..., normalize: bool = ..., copy_X: bool = ..., max_iter: int = ..., tol: float = ..., warm_start: bool = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...

class MultiTaskElasticNetCV(RegressorMixin, LinearModelCV):
    path: Any = ...
    l1_ratio: Any = ...
    eps: Any = ...
    n_alphas: Any = ...
    alphas: Any = ...
    fit_intercept: Any = ...
    normalize: Any = ...
    max_iter: Any = ...
    tol: Any = ...
    cv: Any = ...
    copy_X: Any = ...
    verbose: Any = ...
    n_jobs: Any = ...
    random_state: Any = ...
    selection: Any = ...
    def __init__(self, *, l1_ratio: float = ..., eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., fit_intercept: bool = ..., normalize: bool = ..., max_iter: int = ..., tol: float = ..., cv: Optional[Any] = ..., copy_X: bool = ..., verbose: int = ..., n_jobs: Optional[Any] = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...

class MultiTaskLassoCV(RegressorMixin, LinearModelCV):
    path: Any = ...
    def __init__(self, *, eps: float = ..., n_alphas: int = ..., alphas: Optional[Any] = ..., fit_intercept: bool = ..., normalize: bool = ..., max_iter: int = ..., tol: float = ..., copy_X: bool = ..., cv: Optional[Any] = ..., verbose: bool = ..., n_jobs: Optional[Any] = ..., random_state: Optional[Any] = ..., selection: str = ...) -> None: ...
