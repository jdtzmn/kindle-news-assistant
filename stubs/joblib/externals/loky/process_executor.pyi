import threading
from . import _base
from .backend import get_context as get_context
from .backend.compat import queue as queue, set_cause as set_cause, wait as wait
from .backend.context import cpu_count as cpu_count
from .backend.queues import Queue as Queue, SimpleQueue as SimpleQueue
from .backend.reduction import get_loky_pickler_name as get_loky_pickler_name, set_loky_pickler as set_loky_pickler # type: ignore
from .backend.utils import get_exitcodes_terminated_worker as get_exitcodes_terminated_worker, recursive_terminate as recursive_terminate
from concurrent.futures.process import BrokenProcessPool as _BPPException
from typing import Any, Optional

MAX_DEPTH: Any

class _ThreadWakeup:
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def wakeup(self) -> None: ...
    def clear(self) -> None: ...

class _ExecutorFlags:
    shutdown: bool = ...
    broken: Any = ...
    kill_workers: bool = ...
    shutdown_lock: Any = ...
    def __init__(self, shutdown_lock: Any) -> None: ...
    def flag_as_shutting_down(self, kill_workers: Optional[Any] = ...) -> None: ...
    def flag_as_broken(self, broken: Any) -> None: ...

process_pool_executor_at_exit: Any
EXTRA_QUEUED_CALLS: int

class _RemoteTraceback(Exception):
    tb: Any = ...
    def __init__(self, tb: Optional[Any] = ...) -> None: ...

class _ExceptionWithTraceback(BaseException):
    exc: Any = ...
    tb: Any = ...
    def __init__(self, exc: Any) -> None: ...
    def __reduce__(self): ...

class _WorkItem:
    future: Any = ...
    fn: Any = ...
    args: Any = ...
    kwargs: Any = ...
    def __init__(self, future: Any, fn: Any, args: Any, kwargs: Any) -> None: ...

class _ResultItem:
    work_id: Any = ...
    exception: Any = ...
    result: Any = ...
    def __init__(self, work_id: Any, exception: Optional[Any] = ..., result: Optional[Any] = ...) -> None: ...

class _CallItem:
    work_id: Any = ...
    fn: Any = ...
    args: Any = ...
    kwargs: Any = ...
    loky_pickler: Any = ...
    def __init__(self, work_id: Any, fn: Any, args: Any, kwargs: Any) -> None: ...
    def __call__(self): ...

class _SafeQueue(Queue):
    thread_wakeup: Any = ...
    pending_work_items: Any = ...
    running_work_items: Any = ...
    def __init__(self, max_size: int = ..., ctx: Optional[Any] = ..., pending_work_items: Optional[Any] = ..., running_work_items: Optional[Any] = ..., thread_wakeup: Optional[Any] = ..., reducers: Optional[Any] = ...) -> None: ...

class _ExecutorManagerThread(threading.Thread):
    thread_wakeup: Any = ...
    shutdown_lock: Any = ...
    executor_reference: Any = ...
    executor_flags: Any = ...
    processes: Any = ...
    call_queue: Any = ...
    result_queue: Any = ...
    work_ids_queue: Any = ...
    pending_work_items: Any = ...
    running_work_items: Any = ...
    processes_management_lock: Any = ...
    daemon: bool = ...
    def __init__(self, executor: Any) -> None: ...
    def run(self) -> None: ...
    def add_call_item_to_queue(self) -> None: ...
    def wait_result_broken_or_wakeup(self): ...
    def process_result_item(self, result_item: Any) -> None: ...
    def is_shutting_down(self): ...
    def terminate_broken(self, bpe: Any) -> None: ...
    def flag_executor_shutting_down(self) -> None: ...
    def kill_workers(self) -> None: ...
    def shutdown_workers(self) -> None: ...
    def join_executor_internals(self) -> None: ...
    def get_n_children_alive(self): ...

class LokyRecursionError(RuntimeError): ...
class BrokenProcessPool(_BPPException): ...
class TerminatedWorkerError(BrokenProcessPool): ...
BrokenExecutor = BrokenProcessPool

class ShutdownExecutorError(RuntimeError): ...

class ProcessPoolExecutor(_base.Executor):
    def __init__(self, max_workers: Optional[Any] = ..., job_reducers: Optional[Any] = ..., result_reducers: Optional[Any] = ..., timeout: Optional[Any] = ..., context: Optional[Any] = ..., initializer: Optional[Any] = ..., initargs: Any = ..., env: Optional[Any] = ...) -> None: ...
    def submit(self, fn: Any, *args: Any, **kwargs: Any): ...
    def map(self, fn: Any, *iterables: Any, **kwargs: Any): ... # type: ignore
    def shutdown(self, wait: bool = ..., kill_workers: bool = ...) -> None: ...
