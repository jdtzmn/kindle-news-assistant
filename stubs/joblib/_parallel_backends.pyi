from ._multiprocessing_helpers import mp as mp
from .executor import get_memmapping_executor as get_memmapping_executor
from .externals.loky import cpu_count as cpu_count, process_executor as process_executor
from .my_exceptions import WorkerInterrupt as WorkerInterrupt
from .pool import MemmappingPool as MemmappingPool
from abc import ABCMeta, abstractmethod
from typing import Any, Optional

class ParallelBackendBase(metaclass=ABCMeta):
    supports_timeout: bool = ...
    supports_inner_max_num_threads: bool = ...
    nesting_level: Any = ...
    inner_max_num_threads: Any = ...
    def __init__(self, nesting_level: Optional[Any] = ..., inner_max_num_threads: Optional[Any] = ..., **kwargs: Any) -> None: ...
    MAX_NUM_THREADS_VARS: Any = ...
    TBB_ENABLE_IPC_VAR: str = ...
    @abstractmethod
    def effective_n_jobs(self, n_jobs: Any) -> Any: ...
    @abstractmethod
    def apply_async(self, func: Any, callback: Optional[Any] = ...) -> Any: ...
    parallel: Any = ...
    def configure(self, n_jobs: int = ..., parallel: Optional[Any] = ..., prefer: Optional[Any] = ..., require: Optional[Any] = ..., **backend_args: Any): ...
    def start_call(self) -> None: ...
    def stop_call(self) -> None: ...
    def terminate(self) -> None: ...
    def compute_batch_size(self): ...
    def batch_completed(self, batch_size: Any, duration: Any) -> None: ...
    def get_exceptions(self): ...
    def abort_everything(self, ensure_ready: bool = ...) -> None: ...
    def get_nested_backend(self): ...
    def retrieval_context(self) -> None: ...
    @staticmethod
    def in_main_thread(): ...

class SequentialBackend(ParallelBackendBase):
    uses_threads: bool = ...
    supports_sharedmem: bool = ...
    def effective_n_jobs(self, n_jobs: Any): ...
    def apply_async(self, func: Any, callback: Optional[Any] = ...): ...
    def get_nested_backend(self): ...

class PoolManagerMixin:
    def effective_n_jobs(self, n_jobs: Any): ...
    def terminate(self) -> None: ...
    def apply_async(self, func: Any, callback: Optional[Any] = ...): ...
    def abort_everything(self, ensure_ready: bool = ...) -> None: ...

class AutoBatchingMixin:
    MIN_IDEAL_BATCH_DURATION: float = ...
    MAX_IDEAL_BATCH_DURATION: int = ...
    def __init__(self, **kwargs: Any) -> None: ...
    def compute_batch_size(self): ...
    def batch_completed(self, batch_size: Any, duration: Any) -> None: ...
    def reset_batch_stats(self) -> None: ...

class ThreadingBackend(PoolManagerMixin, ParallelBackendBase):
    supports_timeout: bool = ...
    uses_threads: bool = ...
    supports_sharedmem: bool = ...
    parallel: Any = ...
    def configure(self, n_jobs: int = ..., parallel: Optional[Any] = ..., **backend_args: Any): ... # type: ignore

class MultiprocessingBackend(PoolManagerMixin, AutoBatchingMixin, ParallelBackendBase):
    supports_timeout: bool = ...
    def effective_n_jobs(self, n_jobs: Any): ...
    parallel: Any = ...
    def configure(self, n_jobs: int = ..., parallel: Optional[Any] = ..., prefer: Optional[Any] = ..., require: Optional[Any] = ..., **memmappingpool_args: Any): ...
    def terminate(self) -> None: ...

class LokyBackend(AutoBatchingMixin, ParallelBackendBase):
    supports_timeout: bool = ...
    supports_inner_max_num_threads: bool = ...
    parallel: Any = ...
    def configure(self, n_jobs: int = ..., parallel: Optional[Any] = ..., prefer: Optional[Any] = ..., require: Optional[Any] = ..., idle_worker_timeout: int = ..., **memmappingexecutor_args: Any): ...
    def effective_n_jobs(self, n_jobs: Any): ...
    def apply_async(self, func: Any, callback: Optional[Any] = ...): ...
    @staticmethod
    def wrap_future_result(future: Any, timeout: Optional[Any] = ...): ...
    def terminate(self) -> None: ...
    def abort_everything(self, ensure_ready: bool = ...) -> None: ...

class ImmediateResult:
    results: Any = ...
    def __init__(self, batch: Any) -> None: ...
    def get(self): ...

class SafeFunction:
    func: Any = ...
    def __init__(self, func: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...

class FallbackToBackend(Exception):
    backend: Any = ...
    def __init__(self, backend: Any) -> None: ...
