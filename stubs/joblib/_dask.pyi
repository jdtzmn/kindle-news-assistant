from .parallel import AutoBatchingMixin as AutoBatchingMixin, BatchedCalls as BatchedCalls, ParallelBackendBase as ParallelBackendBase, parallel_backend as parallel_backend
from dask.utils import itemgetter as itemgetter
from typing import Any, Optional

def is_weakrefable(obj: Any): ...

class _WeakKeyDictionary:
    def __init__(self) -> None: ...
    def __getitem__(self, obj: Any): ...
    def __setitem__(self, obj: Any, value: Any) -> None: ...
    def __len__(self): ...
    def clear(self) -> None: ...

class Batch:
    def __init__(self, tasks: Any) -> None: ...
    def __call__(self, tasks: Optional[Any] = ...): ...

class DaskDistributedBackend(AutoBatchingMixin, ParallelBackendBase):
    MIN_IDEAL_BATCH_DURATION: float = ...
    MAX_IDEAL_BATCH_DURATION: float = ...
    supports_timeout: bool = ...
    client: Any = ...
    data_futures: Any = ...
    wait_for_workers_timeout: Any = ...
    submit_kwargs: Any = ...
    waiting_futures: Any = ...
    def __init__(self, scheduler_host: Optional[Any] = ..., scatter: Optional[Any] = ..., client: Optional[Any] = ..., loop: Optional[Any] = ..., wait_for_workers_timeout: int = ..., **submit_kwargs: Any) -> None: ...
    def __reduce__(self): ...
    def get_nested_backend(self): ...
    parallel: Any = ...
    def configure(self, n_jobs: int = ..., parallel: Optional[Any] = ..., **backend_args: Any): ...
    call_data_futures: Any = ...
    def start_call(self) -> None: ...
    def stop_call(self) -> None: ...
    def effective_n_jobs(self, n_jobs: Any): ...
    def apply_async(self, func: Any, callback: Optional[Any] = ...): ...
    def abort_everything(self, ensure_ready: bool = ...) -> None: ...
    def retrieval_context(self) -> None: ...
